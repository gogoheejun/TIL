매핑은 다음종류가 있음

- 객체와 테이블 매핑: @Entity, @Table
- 필드와 칼럼 매핑: @Column
- 기본 키 매핑: @Id
- 연관관계 매핑: @ManyToOne,@JoinColumn

## @Entity

• @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. 
• JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수

주의:

• 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) 
• final 클래스, enum, interface, inner 클래스 사용X 
• 저장할 필드에 final 사용 X

```sql
@Table(name="",catalog= 이런식으로 더 속성 정할 수 있다)
```

![Untitled](https://user-images.githubusercontent.com/78577071/128055534-257c3e73-9927-4ece-829b-7b7855e9e76c.png)


# 데이터베이스 스키마 자동생성

매핑하기 전에 이 개념 먼저!

persistence.xml가서 다음 속성넣으면 디비에 있는 기존테이블 삭제후 다시생성함

<!--<property name="hibernate.hbm2ddl.auto" value="create" />-→

vlaue에 다음 종류의 속성 넣을수있음. 

create: 기존테이블 삭제 후 다시 생성 (DROP + CREATE) 
create-drop: create와 같으나 종료시점에 테이블 DROP
update: 변경분만 반영(운영DB에는 사용하면 안됨)
validate: 엔티티와 테이블이 정상 매핑되었는지만 확인
none: 사용하지 않음

주의:

운영 장비에는 절대 create, create-drop, update 사용하면 안된다

 즉. 로컬피씨에서만 자유롭게 하고 운영서버에선 하지마라.

예시.

```sql
package hellojpa; 
import javax.persistence.*; 
import java.time.LocalDate; 
import java.time.LocalDateTime; 
import java.util.Date; 
@Entity 
public class Member { 
 @Id 
 private Long id; 
 @Column(name = "name") 
 private String username; 
 private Integer age; 
 @Enumerated(EnumType.STRING) 
 private RoleType roleType; 
 @Temporal(TemporalType.TIMESTAMP)  
 private Date createdDate; 
 @Temporal(TemporalType.TIMESTAMP) 
 private Date lastModifiedDate; 
 @Lob 
 private String description; 
 //Getter, Setter… 
}
```

@Enumerated는 RoleType의 원소들(관리자,회원)을 표현해주기 위함임

@Temporal은 날짜관련임.Date로 날짜정보를 줄 때에는 DB에 맞춰서 줌. TemporalType에는 타입이 3가지 있는데, DATE은 날짜, TIME은 시간, TIMESTAMP는 날짜시간 둘다임.

@Lob은 varchar를 넘어서는 큰 숫자를 줄 때.

@Transient도 있는데 얘는 모델에만 만들고, 디비에는 안넣고 싶을때임

- @Column

![Untitled 1](https://user-images.githubusercontent.com/78577071/128055560-632483ae-abfe-4502-99bb-80e43d3573f0.png)

- @Enumerated

자바 enum타입을 매핑할때 사용.

**ORDINAL 절대 사용금지** 위 예에서 User모델에 User,Admin만 있다가 Guset추가되면 0,1,2다 밀려서 기존의 0번이 달라지게 됨.

![Untitled 2](https://user-images.githubusercontent.com/78577071/128055578-528a55b8-81bc-4728-8232-4b93a9b185bd.png)

- @Temporal

자바8이상쓰면 하이버네이트 최신쓰니까 솔직히 필요없음 그냥 다음처럼 쓰면 됨

```sql
private LocalDate testLocalDate; //db의 date타입으로
private LocalDateTime testLocalDateTime; //db의 timestamp타입으로 생성됨
```

- @Lob

매핑하는 필드타입이 문자면  디비에 CLOB으로 매핑되고, 나머지는 BLOB으로 매핑됨

# 기본키 매핑

직접 할당하고 싶으면, @Id만 붙이면 됨. 그

자동생성하고 싶다면, @GeneratedValue도 같이 쓰면 됨

```sql
@Entity
public class Member {
    @Id
		@GenereatedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
```

• **IDENTITY**: 데이터베이스에 위임, MYSQL →디비 야 걍 니 맘대로 해라!
• **SEQUENCE**: 데이터베이스 시퀀스 오브젝트 사용(알아서 하나씩 올라가는거)
• **TABLE**: 키 생성용 테이블 사용, 모든 DB에서 사용
• **AUTO**: 방언에 따라 자동 지정, 이게 디폴트

각각의 전략들마다 장단이 있는데.. 

어떤게 권장되는가?

Long형(int나 Long이나 성능차이 안나거의) + 대체키(seq같은거) + 키 생성전략(auto or sequence) 사용

- IDENTITY 전략특징

일단 이거 쓰면 id에 값을 넣어서 주면 안됨(널로 insert해야함). 일단 디비에 들어가야 pk가 생성되는 것임. 여기서 문제발생. 

jpa는 영속성 컨텍스트에서 관리하려면 무조건 pk가 있어야함. 영속상태가 됐다는건 1차캐시안에 들어갔단 거고, 1차캐시는 다음처럼 @id에 pk가 들어감

![Untitled 3](https://user-images.githubusercontent.com/78577071/128055589-f6b9afb4-db16-4dce-bc91-875ed9c307b4.png)

고로, 이 문제를 피하기 위해서 

persist하는 순간 쿼리를 날리게 됨.

```sql
try{
            Member member = em.find(Member.class, 150L);
            member.setName("AAAA");
            
            System.out.println("===========");
            em.persist(member);
						System.out.println("member = "+member.getId());
            System.out.println("===========");
            
            tx.commit();
```

그래서 위처럼 getId가 가능해짐. commit도 안했는데 그전에 디비에 가서 데이터가져오게 되고, 영속성컨텍스트 안에 넣겠지.

- SEQUENCE 전략 - 특징

![Untitled 4](https://user-images.githubusercontent.com/78577071/128055598-d7edba26-069d-4792-a594-1034f4d52e12.png)

```sql
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ",
        initialValue = 1, allocationSize = 50
)
public class Member {
    @Id
		@GeneratedValue(strategy=GenerationType.SEQUENCE,generator="MEMBER_SEQ_GENERATOR")
    private Long id;
```

얘도 마찬가지로 디비에 가봐야 시퀀스가 몇인지 알 수 있음

얘도 persist할때 디비에 가서 시퀀스번호를 가져와서 영속성컨텍스트에 넣고, commit()할때 영속성컨텍스트의 쿼리를 쏘는거임. 

근데 이러면 persist할때마다 계속 시퀀스가져와야 하는거면 네트워크때매 느린거아닌가?→allocationSize로 설정할 수 있음

allocationSize=50으로 설정하고 한번 호출하면 시퀀스를 디비에 50까지 미리 올려놓고 메모리에서 그 크기만 큼 씀( id에다가 하나씩 부여) 51되면 다시 50개 디비에 쌓아놓고, 메모리는 51부터 시작하겟지

# 앤티티 매핑 예제

![Untitled 5](https://user-images.githubusercontent.com/78577071/128055611-b8fd49a2-c37a-47eb-8eab-74f3818c0a0c.png)

![Untitled 6](https://user-images.githubusercontent.com/78577071/128055618-bda61763-a692-4374-b0d2-7e180f5158db.png)

위처럼 하면 Order테이블에서 주문번호만 아는 상황에서 그 주문을 한 사람이 알고 싶을 때 다음처럼 해야 함.

```sql
Order order = em.find(Order.class, 1L);//주문번호가 1번이라 가정
Long memberId = order.getMemberId();
Member member = em.find(Member.class, memberId);
```

위처럼 객체지향스럽지 않게 해야함. 문제의 원인은 ORM으로 짜지 않고 관계형디비에 맞춰 엔티티를 설계한 것임.

- 이처럼,, 데이터 중심 설계의 문제점:

테이블의 외래키를 객체에 그대로 가져옴

객체 그래프 탐색 불가능

참조가 없으므로 UML도 잘못됨

아래처럼 하고 싶어..

```sql
Member member = order.gerMember();//이렇게 하고 싶어.
```

 해결방법: 연관관계 매핑
